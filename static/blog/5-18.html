<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />

<link rel="stylesheet" href="/static/css/bootstrap.css" type="text/css"/>
<link rel="stylesheet" href="/static/css/blog.css" type="text/css"/>

<script type="text/javascript">
var _speedMark = new Date();
</script>
</head>

<body>
<div class="navbar navbar-fixed-top">
  <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
        <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav ml90">
          <li data-slide="1" class="col-xs-4"><a href="/"  id="menu-link-1"><span class="glyphicon glyphicon-home"></span>首页</a></li>
          <li data-slide="2" class="col-xs-4 active"><a href="/blog/" id="menu-link-2"><span class="glyphicon glyphicon-book"></span>博客</a></li>
          <li data-slide="3" class="col-xs-4"><a href="/team/" id="menu-link-3" target="_blank"><span class="glyphicon glyphicon-user"></span>团队</a></li>
        </ul>
      <div class="row">
        <div class="col-xs-4 active-menu"></div>
      </div>
          
      </div>
    </div>
</div>


<div class="content">
	<p>靠</p>
<p><strong>起源</strong></p>
<p>写时复制英文名字叫“copy-on-write”，简称“cow”，又名“靠”</p>
<p>今天查了下这个&quot;cow&quot;，原来起源于*nix内存管理机制，后来广泛应用在其它开发语言上，C++的STL，还有PHP，相信很多人都了解这个写时复制，经常跟别人侃得甚欢。</p>
<pre><code>$foo = &#39;foo&#39;;
$bar = $foo;</code></pre>
<p><strong>不会</strong></p>
<p>初写这样的PHP代码时,常会问，这样的话会不会因为复制而占用更多内存，旁边会有人说，不会。当然你不知道他说的“不会”，是指“不占用”，还是“我不知道”。后来，了解到<code>memory_get_usage()</code>这函数后，亲自测试验证，确实没有成倍增加。</p>
<pre><code>&lt;?php
var_dump(memory_get_usage());
$foo = &#39;foooooooooooooooooooooooooooooo&#39;;
var_dump(memory_get_usage());
$bar = $foo;
var_dump(memory_get_usage());
------ 结果 -------
int(121704)
int(121840) // 与前者相差 echo $((840-704)) = 136
int(121888) // 与前者相差 echo $((888-840)) = 48</code></pre>
<p><strong>xdebug管中窥豹</strong></p>
<p>神奇的是无论<span class="math"><em>f</em><em>o</em><em>o</em><em>变</em><em>量</em><em>多</em><em>大</em>，<em>复</em><em>制</em></span>foo到$bar时，内存消耗只增加48，这48是什么东西呢？这个时候，得请xdebug来了解下，到底发生了什么事情。</p>
<pre><code>&lt;?php
$foo = &#39;foo&#39;;
xdebug_debug_zval(&#39;foo&#39;);
$bar = $foo;
xdebug_debug_zval(&#39;foo&#39;);
xdebug_debug_zval(&#39;bar&#39;);
$bar = &#39;bar&#39;;
xdebug_debug_zval(&#39;foo&#39;);
xdebug_debug_zval(&#39;bar&#39;);
------ 结果 -------    
foo: (refcount=1, is_ref=0)=&#39;foo&#39; // copy foo before
foo: (refcount=2, is_ref=0)=&#39;foo&#39; // copy foo after
bar: (refcount=2, is_ref=0)=&#39;foo&#39; // write bar befor
foo: (refcount=1, is_ref=0)=&#39;foo&#39; // write bar after
bar: (refcount=1, is_ref=0)=&#39;bar&#39; // write bar after</code></pre>
<p>注意观察会发现refcount的值在copy foo和write bar的时候发生了变化，这过程就是PHP的写时复制。好吧，我这样说，跟高中老师说的，看这就是能量守恒定律一样无趣。</p>
<p><strong>PHP变量结构体</strong></p>
<p>其实refcount在PHP内核中，是变量存储的结构体的一个成员，完整名称<code>refcount__gc</code>，上述xdebug打印出来的is_ref也是变量结构体的一个成员<code>is_ref__gc</code>，查看它完整的定义可以查看PHP源码Zend/zend.h</p>
<pre><code>struct _zval_struct {                                                                                                                            
    /* Variable information */
    zvalue_value value;   /* value */
    zend_uint refcount__gc;
    zend_uchar type;   /* active type */
    zend_uchar is_ref__gc;
};</code></pre>
<p>refcount_<em>gc是记录变量引用次数，当<span class="math"><em>b</em><em>a</em><em>r</em> = </span>oo的时候，foo的refcount加一，由于bar与foo是同指向一个变量，引用计数同为2。当bar值被改写时，发生了写时复制，这结构体指向的内在块已经不能同时支持两个值了，于是内核就做了复制一份foo出来给bar，并设置其值为bar。is</em>ref__gc是用来标识是否为引用的，也就是说当我们对变量进行引用的时候，它就派上用场了。</p>
<p>我们先来看PHP内核是如何创建为我们创建一个变量，复制变量和引用变量。PHP是一个弱类型变量语言，没有type的说法，但PHP是由C写的，C类型定义和使用有着严格的要求。</p>
<p><strong>创建变量</strong></p>
<pre><code>&lt;?php
$foo = &#39;FOO&#39;

// PHP内核创建$foo变量
zval *foovar;
MAKE_STD_ZVAL(foovar); // 内核专门封装为变量申请内存空间的宏
ZVAL_STRING(fooval, &quot;FOO&quot;, 1); // type =&gt; ZVAL_STRING, value =&gt; &quot;FOO&quot;
ZEND_SET_SYMBOL(EG(active_symbol_table), &quot;foo&quot;, foovar); // 把$foo加入当前作用域的符号表中，使之在后面可以在symbo_table中可以检索出$foo，也就是PHP代码中要使用$foo的时候。</code></pre>
<p>现在看来我们简单的写了一个<code>$foo = 'FOO';</code>，内核是这样来给我们做底层的事情，我们不用担心内存到底应该分配多少，还得释放，PHP是不是很人性，让PHP开发者轻松就入门来，看到PHP的世界。</p>
<p><strong>复制变量</strong></p>
<pre><code>&lt;?php
$foo = &#39;FOO&#39;;
$bar = $foo;

// PHP内核创建$foo变量
zval *foovar;
MAKE_STD_ZVAL(foovar);
ZVAL_STRING(fooval, &quot;FOO&quot;, 1); // type =&gt; ZVAL_STRING, value =&gt; &quot;FOO&quot;
ZEND_SET_SYMBOL(EG(active_symbol_table), &quot;foo&quot;, foovar); // 
ZVAL_ADDREF(foovar); //显式的增加了foovar结构体的refcount__gc
zend_hash_add(EG(active_symbol_table), &quot;bar&quot;, sizeof(&quot;bar&quot;),&amp;foovar, sizeof(zval*), NULL);    </code></pre>
<p><strong>引用变量</strong></p>
<pre><code>&lt;?php
$foo = &#39;FOO&#39;;
$bar = &amp;$foo;

// PHP内核创建$foo变量
zval *foovar;
MAKE_STD_ZVAL(foovar);
ZVAL_STRING(fooval, &quot;FOO&quot;, 1); // type =&gt; ZVAL_STRING, value =&gt; &quot;FOO&quot;
zend_hash_add(EG(active_symbol_table), &quot;bar&quot;, sizeof(&quot;bar&quot;),&amp;foovar, sizeof(zval*), NULL);    
zend_hash_add(EG(active_symbol_table), &quot;bar&quot;, sizeof(&quot;bar&quot;),&amp;foovar, sizeof(zval*), NULL); // $bar、$foo同指向一个内在地址  </code></pre>
<p><strong>复制、引用多重组合</strong></p>
<pre><code>&lt;?php
$foo = &#39;foo&#39;;
xdebug_debug_zval(&#39;foo&#39;);
$bar = $foo;
xdebug_debug_zval(&#39;foo&#39;);
xdebug_debug_zval(&#39;bar&#39;);
// 增加一个引用
$hua = &amp;$foo;
xdebug_debug_zval(&#39;foo&#39;);
xdebug_debug_zval(&#39;bar&#39;);
xdebug_debug_zval(&#39;hua&#39;);
------ 结果 -------
1.foo: (refcount=1, is_ref=0)=&#39;foo&#39; // copy foo befor
2.foo: (refcount=2, is_ref=0)=&#39;foo&#39; // copy foo after
3.bar: (refcount=2, is_ref=0)=&#39;foo&#39; 
4.foo: (refcount=2, is_ref=1)=&#39;foo&#39; // ref foo after
5.bar: (refcount=1, is_ref=0)=&#39;foo&#39;
6.hua: (refcount=2, is_ref=1)=&#39;foo&#39;</code></pre>
<p>都知道当引用的时候，改变<span class="math"><em>f</em><em>o</em><em>o</em>, </span>hua两者其一值，另外一变量也跟着变化。总结起来就是</p>
<ul>
<li>当只有复制的时候，refcount++（看结果2）</li>
<li>当只有引用的时候，is_ref会由0改写成1</li>
<li>当一个变量既有复制也被引用时，引用与被引用refcount、is_ref一致，复制变量refcount=1, is_ref=0（看结果4-6）</li>
</ul>
<p>其实，PHP很聪明的，当然每个语言都是，尤其是C，当之无愧！PHP内核还专门定义了8种类型来支持我们在PHP代码中创建的所有类型，太让我们变懒惰了。看完这个类型列表，会对PHP内核实现有更深的了解。</p>
<ul>
<li><strong>IS_NULL</strong>
<ul>
<li>第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。</li>
<li>这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</li>
</ul></li>
<li><strong>IS_BOOL</strong>
<ul>
<li>布尔类型的变量有两个值，true或者false。</li>
<li>在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</li>
</ul></li>
<li><strong>IS_LONG</strong>
<ul>
<li>PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数</li>
<li>如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算</li>
<li>因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</li>
<li>例子：<span class="math"><em>a</em> = 2147483647; </span>a++; echo $a;//会正确的输出 2147483648；</li>
</ul></li>
<li><strong>IS_DOUBLE</strong>
<ul>
<li>PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。</li>
<li>我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数，用计算机来处理浮点数简直就是一场噩梦。</li>
</ul></li>
<li><strong>IS_STRING</strong>
<ul>
<li>PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。</li>
<li>与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</li>
</ul></li>
<li><strong>IS_ARRAY</strong>
<ul>
<li>数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳。</li>
<li>每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</li>
</ul></li>
<li><strong>IS_OBJECT</strong>
<ul>
<li>和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。</li>
</ul></li>
<li><strong>IS_RESOURCE</strong>
<ul>
<li>有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。</li>
</ul></li>
</ul>
<p><a href="http://www.walu.cc/phpbook/2.1.md">引自www.walu.cc</a></p>
</div>

<hr class="blog-hr">

<div class="container blog-container prev-next-box">
  <ul class="pager">
    <li class="previous"><a href="javascript:void(0);" id="prev">&larr; Older</a></li>
    <li class="next"><a href="javascript:void(0);" id="next">Newer &rarr;</a></li>
  </ul>
</div>

<div class="content" data-slide="1">
	<div class="blog-container">
		<div id="home-row-1" class="clearfix">
			<div id="comments"></div>
		</div>
	</div>
</div>

<div class="container blog-container comment-box">
		<form class="form-horizontal" role="form">
	  <div class="form-group">
	    <div class="col-sm-3">
	      <input type="text" class="form-control js-name" placeholder="名字不重要">
	    </div>
	  </div>
	  <div class="form-group">
	    <div class="col-sm-10">
	      <textarea class="form-control inputComment js-comment" placeholder="深有感触，写点我的想法"> </textarea>
	    </div>
	  </div>
	  <div class="form-group">
	    <div class="col-sm-10">
	      <button type="submit" class="btn btn-default js-submit">发表评论</button>
	    </div>
	  </div>
	</form>
</div>
<!-- <div id="blog-footer"><a href="http://e.weibo.com/csdnsupport/profile" target="_blank" class="weibo">微博</a> | <a href="http://e.weibo.com/csdnsupport/profile" target="_blank" class="glyphicon glyphicon-envelope email-footer">wushuiyong@huamanshu.com</a> </div> -->
<div id="blog-footer">©2014 huamanshu. All rights reserved</div><div class="hide" style="display:none"><script type="text/javascript" src="http://hm.baidu.com/h.js?fb1a70589b6397ff055728e0196175d5"></script></div>
<script src="/static/js/jquery-1.10.2.min.js" type="text/javascript"></script>
<script src="/static/js/jquery.easing.1.3.js" type="text/javascript"></script>
<script src="/static/js/script.js" type="text/javascript"></script>
<script>
$(document).ready(function(e) {
  var lis = $('.nav > li');
  menu_focus( lis[1], 1 );
  
  var sprintf = function() {
      var arg = arguments,
          str = arg[0] || '',
          i, n;
      for (i = 1, n = arg.length; i < n; i++) {
          str = str.replace(/%s/, arg[i]);
      }
      return str;
  }

  // 初始化评论
  var initComment = function() {
    $.ajax({
      'type' : 'GET',
      'url'  : '/home/blog/getComment/',
      'data' : 'id=' + encodeURIComponent(window.location.href),
      'success' : function(data) {
          var tpl = '';
          for (key in data.comments) {
              var c = data.comments[key];
              tpl += sprintf("<blockquote><p><em>%s</em>%s</p></blockquote>", c.name, c.comment);
          }
          $('#comments').html(tpl).show();
      }
    })
  }
  initComment();

  // 初始化浏览次数
  var initViewCount = function() {
    $.ajax({
      'type' : 'GET',
      'url'  : '/home/blog/viewCount/',
      'data' : 'id=' + encodeURIComponent(window.location.href),
      'success' : function(data) {
          $('.time').text(data.time);
          $('.view').text(data.view);
      }
    });
  }
  initViewCount();

  // 获取上一篇下一篇
  var initNextPrev = function() {
    $.ajax({
      'type' : 'GET',
      'url'  : '/home/blog/getNextPrev/',
      'data' : 'id=' + encodeURIComponent(window.location.href),
      'success' : function(data) {
        var re = /\/index\d.html/
        var nTitle = re.test(data.n.url) ? '下一页' : data.n.title;
        var pTitle = re.test(data.p.url) ? '上一页' : data.p.title;
        data.n ? $('#next').attr('href', data.n.url).html(nTitle + ' &rarr;') : $('#next').hide();
        data.p ? $('#prev').attr('href', data.p.url).html('&larr; ' + pTitle) : $('#prev').hide();
      }
    });
  }
  initNextPrev();

  // 写完点提交或者ctrl+enter
  if (event.ctrlKey && event.keyCode == '13') {
    addComment();
  }
  $('.js-submit').click(function(e) {
    e.preventDefault();
    addComment();
  })

  // 添加评论
  var addComment = function() {
    var name = $('.js-name').val();
    var comment = $('.js-comment').val();

    $.ajax({
      'type' : 'POST',
      'url'  : '/home/blog/addComment/',
      'data' : sprintf('name=%s&comment=%s&id=%s', encodeURIComponent(name), encodeURIComponent(comment), encodeURIComponent(window.location.href)),
      'success' : function(data) {
          initComment();
          $('.js-name').val('');
          $('.js-comment').val('');
      }
    })
  }
});

</script>
<script type="text/javascript" src="http://hm.baidu.com/h.js?fb1a70589b6397ff055728e0196175d5"></script>

</body>
</html>
